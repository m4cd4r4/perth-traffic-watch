<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SwanFlow Frame Generator</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0a0f1e;
      color: #fff;
      font-family: 'Courier New', monospace;
    }
    #controls {
      margin-bottom: 20px;
      padding: 15px;
      background: #1f2937;
      border-radius: 8px;
    }
    button {
      padding: 10px 20px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
    }
    button:hover {
      background: #2563eb;
    }
    #progress {
      margin-top: 10px;
      font-size: 14px;
    }
    canvas {
      border: 1px solid #374151;
      display: block;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="controls">
    <h2>SwanFlow Traffic Animation Frame Generator</h2>
    <button onclick="generateAllFrames()">Generate 120 Frames</button>
    <button onclick="generateSingleFrame()">Preview Single Frame</button>
    <div id="progress"></div>
  </div>
  <canvas id="canvas" width="1920" height="1080"></canvas>

  <script>
    const WIDTH = 1920;
    const HEIGHT = 1080;
    const FRAME_COUNT = 120;

    // Traffic colors
    const TRAFFIC_COLORS = {
      flowing: '#10b981',
      moderate: '#f59e0b',
      heavy: '#ef4444',
      gridlock: '#991b1b'
    };

    // Road waypoints (Perth corridors)
    const corridorWaypoints = {
      'Mounts Bay Rd': [
        [-31.9755360, 115.8180240], [-31.9733899, 115.8256410], [-31.9728911, 115.8265899],
        [-31.9726546, 115.8274435], [-31.9724305, 115.8289419], [-31.9722547, 115.8308715],
        [-31.9719219, 115.8321438], [-31.9715072, 115.8331964], [-31.9710934, 115.8336485],
        [-31.9704117, 115.8340935], [-31.9701018, 115.8345177], [-31.9696950, 115.8357989],
        [-31.9693711, 115.8365875], [-31.9689912, 115.8371631], [-31.9684943, 115.8377125],
        [-31.9678280, 115.8383774], [-31.9668462, 115.8390952], [-31.9662305, 115.8395033],
        [-31.9653717, 115.8398791]
      ],
      'Stirling Hwy': [
        [-31.9820, 115.7900], [-31.9834402, 115.7802709], [-31.9850921, 115.7755445],
        [-31.9870, 115.7720], [-31.9890887, 115.7685801], [-31.9910607, 115.7675329],
        [-31.9925, 115.7665], [-31.993, 115.766], [-31.994, 115.765]
      ],
      'Mitchell Fwy': [
        [-31.9617537, 115.8474375], [-31.9600697, 115.8474955], [-31.9586325, 115.8490672],
        [-31.9569363, 115.8494396], [-31.9553135, 115.8494540], [-31.9544093, 115.8488992],
        [-31.9527661, 115.8483345], [-31.9508178, 115.8490068], [-31.9493950, 115.8496822],
        [-31.9477915, 115.8501012], [-31.9460202, 115.8498387], [-31.9440531, 115.8485092],
        [-31.9412033, 115.8439939], [-31.9396551, 115.8405922], [-31.9379469, 115.8389929],
        [-31.9307069, 115.8350879], [-31.9261945, 115.8302721], [-31.9236279, 115.8269383],
        [-31.9194459, 115.8240925], [-31.9144881, 115.8233710], [-31.9106849, 115.8224215],
        [-31.9017170, 115.8208361], [-31.8990018, 115.8175891]
      ]
    };

    let bounds;

    // Calculate map bounds
    function calculateBounds() {
      let minLat = Infinity, maxLat = -Infinity;
      let minLng = Infinity, maxLng = -Infinity;

      Object.values(corridorWaypoints).forEach(waypoints => {
        waypoints.forEach(([lat, lng]) => {
          minLat = Math.min(minLat, lat);
          maxLat = Math.max(maxLat, lat);
          minLng = Math.min(minLng, lng);
          maxLng = Math.max(maxLng, lng);
        });
      });

      const latPadding = (maxLat - minLat) * 0.1;
      const lngPadding = (maxLng - minLng) * 0.1;

      return {
        minLat: minLat - latPadding,
        maxLat: maxLat + latPadding,
        minLng: minLng - lngPadding,
        maxLng: maxLng + lngPadding,
        minMercN: Math.log(Math.tan((Math.PI / 4) + ((minLat - latPadding) * Math.PI / 180 / 2))),
        maxMercN: Math.log(Math.tan((Math.PI / 4) + ((maxLat + latPadding) * Math.PI / 180 / 2)))
      };
    }

    // Mercator projection
    function latLngToScreen(lat, lng, bounds) {
      const x = (lng - bounds.minLng) / (bounds.maxLng - bounds.minLng);
      const latRad = lat * Math.PI / 180;
      const mercN = Math.log(Math.tan((Math.PI / 4) + (latRad / 2)));
      const y = (mercN - bounds.minMercN) / (bounds.maxMercN - bounds.minMercN);

      return {
        x: x * WIDTH,
        y: (1 - y) * HEIGHT
      };
    }

    // Drawing functions
    function drawRoadLayer(ctx, bounds, opacity = 1) {
      ctx.save();
      ctx.globalAlpha = opacity;

      Object.entries(corridorWaypoints).forEach(([name, waypoints]) => {
        if (waypoints.length < 2) return;
        const screenPoints = waypoints.map(([lat, lng]) => latLngToScreen(lat, lng, bounds));

        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 24;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        ctx.beginPath();
        ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
        screenPoints.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
        ctx.stroke();
      });

      ctx.restore();
    }

    function drawLaneMarkings(ctx, bounds, opacity = 1) {
      ctx.save();
      ctx.globalAlpha = opacity;

      Object.entries(corridorWaypoints).forEach(([name, waypoints]) => {
        if (waypoints.length < 2) return;
        const screenPoints = waypoints.map(([lat, lng]) => latLngToScreen(lat, lng, bounds));

        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.setLineDash([20, 15]);

        ctx.beginPath();
        ctx.moveTo(screenPoints[0].x, screenPoints[0].y);
        screenPoints.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
        ctx.stroke();

        ctx.setLineDash([]);
      });

      ctx.restore();
    }

    function drawGrid(ctx, opacity = 1) {
      ctx.save();
      ctx.globalAlpha = opacity * 0.15;
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 1;

      for (let x = 0; x < WIDTH; x += 100) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, HEIGHT);
        ctx.stroke();
      }

      for (let y = 0; y < HEIGHT; y += 100) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(WIDTH, y);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawTrafficFlow(ctx, bounds, frameProgress, opacity = 1) {
      ctx.save();
      ctx.globalAlpha = opacity;

      const colors = [TRAFFIC_COLORS.flowing, TRAFFIC_COLORS.moderate, TRAFFIC_COLORS.heavy];

      Object.entries(corridorWaypoints).forEach(([name, waypoints], corridorIdx) => {
        if (waypoints.length < 2) return;
        const screenPoints = waypoints.map(([lat, lng]) => latLngToScreen(lat, lng, bounds));
        const color = colors[corridorIdx % colors.length];

        [1, -1].forEach((direction) => {
          const offsetPoints = screenPoints.map((pt, i) => {
            if (i === 0) return pt;
            const prev = screenPoints[i - 1];
            const dx = pt.x - prev.x;
            const dy = pt.y - prev.y;
            const len = Math.sqrt(dx * dx + dy * dy);
            const perpX = -dy / len * 5 * direction;
            const perpY = dx / len * 5 * direction;
            return { x: pt.x + perpX, y: pt.y + perpY };
          });

          // Background solid line
          ctx.strokeStyle = color;
          ctx.lineWidth = 5;
          ctx.globalAlpha = opacity * 0.3;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';

          ctx.beginPath();
          ctx.moveTo(offsetPoints[0].x, offsetPoints[0].y);
          offsetPoints.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();

          // Animated dashed line
          ctx.strokeStyle = color;
          ctx.lineWidth = 4;
          ctx.globalAlpha = opacity * 0.9;

          const dashOffset = (frameProgress * 20 * direction) % 20;
          ctx.setLineDash([8, 12]);
          ctx.lineDashOffset = dashOffset;

          ctx.beginPath();
          ctx.moveTo(offsetPoints[0].x, offsetPoints[0].y);
          offsetPoints.slice(1).forEach(pt => ctx.lineTo(pt.x, pt.y));
          ctx.stroke();

          ctx.setLineDash([]);
        });
      });

      ctx.restore();
    }

    function generateFrame(frameNum, bounds) {
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');

      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      ctx.fillStyle = '#0a0f1e';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      const progress = frameNum / FRAME_COUNT;

      if (frameNum < 30) {
        const roadOpacity = frameNum / 30;
        drawRoadLayer(ctx, bounds, roadOpacity);
      } else if (frameNum < 60) {
        drawRoadLayer(ctx, bounds, 1);
        const laneOpacity = (frameNum - 30) / 30;
        drawLaneMarkings(ctx, bounds, laneOpacity);
      } else if (frameNum < 90) {
        drawRoadLayer(ctx, bounds, 1);
        drawLaneMarkings(ctx, bounds, 1);
        const gridOpacity = (frameNum - 60) / 30;
        drawGrid(ctx, gridOpacity);
      } else {
        drawRoadLayer(ctx, bounds, 1);
        drawLaneMarkings(ctx, bounds, 1);
        drawGrid(ctx, 1);
        const trafficOpacity = (frameNum - 90) / 30;
        drawTrafficFlow(ctx, bounds, progress, trafficOpacity);
      }
    }

    function downloadCanvas(frameNum) {
      const canvas = document.getElementById('canvas');
      const link = document.createElement('a');
      link.download = `assembly_${String(frameNum).padStart(4, '0')}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    async function generateAllFrames() {
      const progressEl = document.getElementById('progress');
      progressEl.textContent = 'Initializing...';

      if (!bounds) bounds = calculateBounds();

      for (let i = 0; i < FRAME_COUNT; i++) {
        generateFrame(i, bounds);

        if ((i + 1) % 10 === 0 || i === 0 || i === FRAME_COUNT - 1) {
          const percent = ((i + 1) / FRAME_COUNT * 100).toFixed(0);
          progressEl.textContent = `Generating frame ${i + 1}/${FRAME_COUNT} (${percent}%)`;
        }

        // Download every frame
        downloadCanvas(i);

        // Small delay to let browser process downloads
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      progressEl.textContent = `Complete! Generated ${FRAME_COUNT} frames. Check your Downloads folder.`;
    }

    function generateSingleFrame() {
      const progressEl = document.getElementById('progress');
      if (!bounds) bounds = calculateBounds();

      generateFrame(60, bounds);  // Preview frame 60
      progressEl.textContent = 'Preview: Frame 60 (mid-animation)';
    }

    // Initialize
    bounds = calculateBounds();
    generateSingleFrame();
  </script>
</body>
</html>
